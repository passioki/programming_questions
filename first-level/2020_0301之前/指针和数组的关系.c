#include <stdio.h>
 
int main(void)
{
    int a[10]={0,1,2,3,4,5,6,7,8,9};
    int* const p = a;
 
    //测试1：（由于影响编译，因此将其注释掉，与其他测试并非在同一次中进行）
    //能否用一个数组变量来初始化一个数组变量？
    //能否用一个const指针来初始化一个const指针？
/*
    int b[10] = a;  //编译无法通过 error：invalid initializer
            //非法的初始化，因此不可以用一个数组变量来初始化一个数组变量
    int* const q = p;             //编译通过，这也是通常的用法
    printf("q=%p,p=%p\n", q, p);  //运行结果 q=0022FEE0,p=0022FEE0
            //可见q和p是一样的，因此可以用一个const指针来初始化一个const指针
*/
    //测试2：（由于影响编译，因此将其注释掉，与其他测试并非在同一次中进行）
    //能否用一个数组变量来初始化一个const指针？
    //能否用一个const指针来初始化一个数组变量？
/*
    int* const q = a;           //编译通过，这也是通常的用法
    printf("q=%p,a=%p\n", q, a);  //运行结果 q=0022FEE0,a=0022FEE0
            //可见q和a是一样的，因此可以用一个数组变量来初始化一个const指针
    int b[10] = p;  //编译无法通过 error：invalid initializer
            //非法的初始化，因此不可以用一个const指针来初始化一个数组变量
*/
    //以下的测试为同一次编译运行
    //测试3：
    //能否对一个数组变量进行sizeof()运算，结果是什么？
    //能否对一个const指针进行sizeof()运算，结果是什么？
 
    printf("sizeof(a)=%d\n", sizeof(a));    //编译通过，运行结果 sizeof(a)=40
    printf("sizeof(p)=%d\n", sizeof(p));    //编译通过，运行结果 sizeof(p)=4
            //sizeof(a)得到的是整个数组的大小4*sizeof(int)
            //sizeof(p)得到的是一个指针的大小
 
    //测试4：
    //数组变量的值是什么？
    //const指针的值是什么？
    //能否对一个数组变量进行“&”运算，结果是什么？
    //能否对一个const指针进行“&”运算，结果是什么？
 
    printf("a=%p\n", a);            //编译通过，运行结果 a=0022FEE8
    printf("p=%p\n", p);            //编译通过，运行结果 p=0022FEE8
    printf("&a=%p\n", &a);          //编译通过，运行结果 &a=0022FEE8
    printf("&a[0]=%p\n", &a[0]);    //编译通过，运行结果 &a[0]=0022FEE8
    printf("&p=%p\n", &p);          //编译通过，运行结果 &p=0022FEE4
            //对数组变量和const指针都能进行“&”运算
            //a,&a,&a[0]的值相同，说明a的值是一个地址，所以可以把a赋给p
            //a与&a相同，都是数组a的第一个元素a[0]的地址
            //p的值就是程序开始时初始化得到的a的值
            //&p取到的是p这个constant量自己在内存中的地址，和普通变量一样
            //a的地址竟然是它自己，这个确实很有趣，可以理解，但有点说不通
 
    //测试5：
    //能否对一个数组变量进行“*”运算？
    //能否对一个const指针进行“*”运算？
 
    printf("*a=%d\n", *a);    //编译通过，运行结果 *a=0
    printf("*p=%d\n", *p);    //编译通过，运行结果 *p=0
            //对数组变量和const指针都能进行“*”运算
            //意义也相同
 
    //测试6：
    //能否对一个数组变量进行“[n]”运算？
    //能否对一个const指针进行“[n]”运算？
 
    printf("a[6]=%d\n", a[6]);    //编译通过，运行结果 a[6]=6
    printf("p[6]=%d\n", p[6]);    //编译通过，运行结果 p[6]=6
            //对数组变量和const指针都能进行“[n]”运算
            //两者运算规律相同，
            //偏移量n实际偏移量的都与指向的类型（如本测试中的int）相关
 
    //测试7：
    //数组变量+1是什么？
    //const指针+1是什么？
 
    printf("a+1=%p\n", a+1);        //编译通过，运行结果 a+1=0022FEEC
    printf("p+1=%p\n", p+1);        //编译通过，运行结果 p+1=0022FEEC
    printf("*(a+1)=%d\n", *(a+1));  //编译通过，运行结果 *(a+1)=1
    printf("*(p+1)=%d\n", *(p+1));  //编译通过，运行结果 *(p+1)=1
    printf("a[1]=%d\n", a[1]);      //编译通过，运行结果 a[1]=1
    printf("p[1]=%d\n", p[1]);      //编译通过，运行结果 p[1]=1
            //第一次写前两句时，用了%d，结果编译warning，说类型是int*
            //所以改为%p,说明a+1和p+1仍为指针
            //与测试4的结果相比较，a+1和a，p+1和p之间都相差sizeof(int)
            //两者运算规律相同，其意义也与[]运算符相同
 
    return 0;
}
